/*----------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported to C++ by Csaba Balazs, University of Szeged
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than 
Coco/R itself) does not fall under the GNU General Public License.
-----------------------------------------------------------------------*/


#if !defined(Taste_COCO_PARSER_H__)
#define Taste_COCO_PARSER_H__

#include <stdarg.h>
#include <math.h>
#include <algorithm>    
#include <vector>
#include <string>

static bool _is_optimizing = true;

inline void printft(int count, const char* format, ... )
{
	for( int i = 0; i < count; i++ ) {
		printf("\t");
	}
	
    va_list args;
    va_start( args, format );
    vfprintf( stdout, format, args );
    va_end( args );	
}

struct Exp
{
	bool canOptimize;
	
	Exp() { canOptimize = _is_optimizing; }
	virtual void eval(int indent) = 0;
	virtual Exp* optimize() = 0;
};

struct IdentExpr : Exp
{
	std::wstring value;

	virtual void eval(int indent) 
	{
		printft(indent, "Field \"%ls\"\r\n", value.c_str());
	}
	
	virtual Exp* optimize() 
	{
		return 0;
	}
};

struct LiteralExpr : Exp
{
	float literal;

	virtual void eval(int indent) 
	{
		printft(indent, "%fF\r\n", literal);
	}
	
	virtual Exp* optimize() 
	{
		return 0;
	}	
};

struct Condition : Exp
{
	Exp* booleanExpression;
	Exp* blockExpression;
	
	virtual void eval(int indent) 
	{
		printft(indent, "conditional\r\n");
		booleanExpression->eval(indent + 1);
		blockExpression->eval(indent + 1);
	}
	
	virtual Exp* optimize() 
	{			
		Exp* p = booleanExpression->optimize();
		if( p ) 
		{
			Exp* old = booleanExpression;
			booleanExpression = p;
			delete old;
		}		
		
		p = blockExpression->optimize();
		if( p ) 
		{
			Exp* old = blockExpression;
			blockExpression = p;
			delete old;
		}		
		
		return 0;
	}
};

struct BlockExpr : Exp
{
	std::vector<Exp*> statements;
	
	virtual void eval(int indent) 
	{
		printft(indent, "block\r\n");
		for( int i = 0; i < statements.size(); ++i ) {
			statements[i]->eval(indent + 1);
		}	
	}
	
	virtual Exp* optimize() 
	{	
		for( int i = 0; i < statements.size(); ++i ) 
		{					
			Exp* p = statements[i]->optimize();
			if( p ) 
			{
				Exp* old = statements[i];
				statements[i] = p;
				delete old;
			}			
		}	
		
		return 0;
	}
};

struct CallExpr : Exp
{	
	std::wstring functionName;
	std::vector<Exp*> arguments;
	
	virtual void eval(int indent) 
	{
		printft(indent, "call method %ls %d\r\n", functionName.c_str(), 
			arguments.size());
		for( int i = 0; i < arguments.size(); ++i ) {
			arguments[i]->eval(indent + 1);
		}
	}
	
	virtual Exp* optimize() 
	{
		for( int i = 0; i < arguments.size(); ++i ) {					
			Exp* p = arguments[i]->optimize();
			if( p ) 
			{
				Exp* old = arguments[i];
				arguments[i] = p;
				delete old;
			}			
		}	
		
		if( functionName == L"sin" && arguments.size() == 1 )
		{
			LiteralExpr* literal_a = dynamic_cast<LiteralExpr*>(arguments[0]);
			if( literal_a != 0 && canOptimize == true )
			{
				float result = sin(literal_a->literal);
				LiteralExpr* r = new LiteralExpr();
				r->literal = result;
				r->canOptimize = true;
				return r;			
			}
		}

		if( functionName == L"cos" && arguments.size() == 1 )
		{
			LiteralExpr* literal_a = dynamic_cast<LiteralExpr*>(arguments[0]);
			if( literal_a != 0 && canOptimize == true )
			{
				float result = cos(literal_a->literal);
				LiteralExpr* r = new LiteralExpr();
				r->literal = result;
				r->canOptimize = true;
				return r;			
			}
		}		
		
		if( functionName == L"tan" && arguments.size() == 1 )
		{
			LiteralExpr* literal_a = dynamic_cast<LiteralExpr*>(arguments[0]);
			if( literal_a != 0 && canOptimize == true )
			{
				float result = tan(literal_a->literal);
				LiteralExpr* r = new LiteralExpr();
				r->literal = result;
				r->canOptimize = true;
				return r;			
			}
		}	
		
		if( functionName == L"sinh" && arguments.size() == 1 )
		{
			LiteralExpr* literal_a = dynamic_cast<LiteralExpr*>(arguments[0]);
			if( literal_a != 0 && canOptimize == true )
			{
				float result = sinh(literal_a->literal);
				LiteralExpr* r = new LiteralExpr();
				r->literal = result;
				r->canOptimize = true;
				return r;			
			}
		}

		if( functionName == L"cosh" && arguments.size() == 1 )
		{
			LiteralExpr* literal_a = dynamic_cast<LiteralExpr*>(arguments[0]);
			if( literal_a != 0 && canOptimize == true )
			{
				float result = cosh(literal_a->literal);
				LiteralExpr* r = new LiteralExpr();
				r->literal = result;
				r->canOptimize = true;
				return r;			
			}
		}		
		
		if( functionName == L"tanh" && arguments.size() == 1 )
		{
			LiteralExpr* literal_a = dynamic_cast<LiteralExpr*>(arguments[0]);
			if( literal_a != 0 && canOptimize == true )
			{
				float result = tanh(literal_a->literal);
				LiteralExpr* r = new LiteralExpr();
				r->literal = result;
				r->canOptimize = true;
				return r;			
			}
		}	
		
		if( functionName == L"asin" && arguments.size() == 1 )
		{
			LiteralExpr* literal_a = dynamic_cast<LiteralExpr*>(arguments[0]);
			if( literal_a != 0 && canOptimize == true )
			{
				float result = asin(literal_a->literal);
				LiteralExpr* r = new LiteralExpr();
				r->literal = result;
				r->canOptimize = true;
				return r;			
			}
		}

		if( functionName == L"acos" && arguments.size() == 1 )
		{
			LiteralExpr* literal_a = dynamic_cast<LiteralExpr*>(arguments[0]);
			if( literal_a != 0 && canOptimize == true )
			{
				float result = acos(literal_a->literal);
				LiteralExpr* r = new LiteralExpr();
				r->literal = result;
				r->canOptimize = true;
				return r;			
			}
		}		
		
		if( functionName == L"atan" && arguments.size() == 1 )
		{
			LiteralExpr* literal_a = dynamic_cast<LiteralExpr*>(arguments[0]);
			if( literal_a != 0 && canOptimize == true )
			{
				float result = atan(literal_a->literal);
				LiteralExpr* r = new LiteralExpr();
				r->literal = result;
				r->canOptimize = true;
				return r;			
			}
		}	
		
		if( functionName == L"sqrt" && arguments.size() == 1 )
		{
			LiteralExpr* literal_a = dynamic_cast<LiteralExpr*>(arguments[0]);
			if( literal_a != 0 && canOptimize == true )
			{
				float result = sqrt(literal_a->literal);
				LiteralExpr* r = new LiteralExpr();
				r->literal = result;
				r->canOptimize = true;
				return r;			
			}
		}							
		
		if( functionName == L"abs" && arguments.size() == 1 )
		{
			LiteralExpr* literal_a = dynamic_cast<LiteralExpr*>(arguments[0]);
			if( literal_a != 0 && canOptimize == true )
			{
				float result = fabs(literal_a->literal);
				LiteralExpr* r = new LiteralExpr();
				r->literal = result;
				r->canOptimize = true;
				return r;			
			}
		}	
		
		if( functionName == L"sign" && arguments.size() == 1 )
		{
			LiteralExpr* literal_a = dynamic_cast<LiteralExpr*>(arguments[0]);
			if( literal_a != 0 && canOptimize == true )
			{
				float result = literal_a->literal < 0 ? -1 : 1;
				LiteralExpr* r = new LiteralExpr();
				r->literal = result;
				r->canOptimize = true;
				return r;			
			}
		}	

		if( functionName == L"radians" && arguments.size() == 1 )
		{
			LiteralExpr* literal_a = dynamic_cast<LiteralExpr*>(arguments[0]);
			if( literal_a != 0 && canOptimize == true )
			{
				float result = (3.14159265358979323846f * literal_a->literal) / 180.0f;
				LiteralExpr* r = new LiteralExpr();
				r->literal = result;
				r->canOptimize = true;
				return r;			
			}
		}		
		
		if( functionName == L"degrees" && arguments.size() == 1 )
		{
			LiteralExpr* literal_a = dynamic_cast<LiteralExpr*>(arguments[0]);
			if( literal_a != 0 && canOptimize == true )
			{
				float result = (180 * literal_a->literal) / 3.14159265358979323846f;
				LiteralExpr* r = new LiteralExpr();
				r->literal = result;
				r->canOptimize = true;
				return r;			
			}
		}			
		
		if( functionName == L"ceil" && arguments.size() == 1 )
		{
			LiteralExpr* literal_a = dynamic_cast<LiteralExpr*>(arguments[0]);
			if( literal_a != 0 && canOptimize == true )
			{
				float result = ceil(literal_a->literal);
				LiteralExpr* r = new LiteralExpr();
				r->literal = result;
				r->canOptimize = true;
				return r;			
			}
		}		
		
		if( functionName == L"floor" && arguments.size() == 1 )
		{
			LiteralExpr* literal_a = dynamic_cast<LiteralExpr*>(arguments[0]);
			if( literal_a != 0 && canOptimize == true )
			{
				float result = floor(literal_a->literal);
				LiteralExpr* r = new LiteralExpr();
				r->literal = result;
				r->canOptimize = true;
				return r;			
			}
		}		
		
		if( functionName == L"clamp" && arguments.size() == 3 )
		{
			LiteralExpr* literal_a = dynamic_cast<LiteralExpr*>(arguments[0]);
			LiteralExpr* literal_b = dynamic_cast<LiteralExpr*>(arguments[1]);
			LiteralExpr* literal_c = dynamic_cast<LiteralExpr*>(arguments[2]);
			if( literal_a != 0 && literal_b != 0 && literal_c != 0 && canOptimize == true )
			{
				float a = literal_a->literal;
				float b = literal_b->literal;
				float c = literal_c->literal;
				float result = c > b ? b : ( c < a ? a : c );
				LiteralExpr* r = new LiteralExpr();
				r->literal = result;
				r->canOptimize = true;
				return r;			
			}
		}
		
		if( functionName == L"lerp" && arguments.size() == 3 )
		{
			LiteralExpr* literal_a = dynamic_cast<LiteralExpr*>(arguments[0]);
			LiteralExpr* literal_b = dynamic_cast<LiteralExpr*>(arguments[1]);
			LiteralExpr* literal_c = dynamic_cast<LiteralExpr*>(arguments[2]);
			if( literal_a != 0 && literal_b != 0 && literal_c != 0 && canOptimize == true )
			{
				float a = literal_a->literal;
				float b = literal_b->literal;
				float c = literal_c->literal;
				float result = c > 1.0f ? 1.0f : ( c < 0.0f ? 0.0f : c );
					  result = a + (b - a) * result;
				LiteralExpr* r = new LiteralExpr();
				r->literal = result;
				r->canOptimize = true;
				return r;			
			}
		}				
		
		if( functionName == L"smoothstep" && arguments.size() == 3 )
		{
			LiteralExpr* literal_a = dynamic_cast<LiteralExpr*>(arguments[0]);
			LiteralExpr* literal_b = dynamic_cast<LiteralExpr*>(arguments[1]);
			LiteralExpr* literal_c = dynamic_cast<LiteralExpr*>(arguments[2]);
			if( literal_a != 0 && literal_b != 0 && literal_c != 0 && canOptimize == true )
			{
				float a = literal_a->literal;
				float b = literal_b->literal;
				float c = literal_c->literal;
				float result = (c - a) / (b - a);
					  result = result > 1.0f ? 1.0f : ( result < 0.0f ? 0.0f : result );
					  result = t * t * (3.0 - 2.0 * t);
				LiteralExpr* r = new LiteralExpr();
				r->literal = result;
				r->canOptimize = true;
				return r;			
			}
		}		
		
		return 0;
	}
};


struct ComparisonExp : Exp
{	
	int  op;
	Exp* a;
	Exp* b;
	
	ComparisonExp() : op(0)
	{
	}

	virtual void eval(int indent) 
	{
		switch( op )
		{
			case 0: printft(indent, "??\r\n"); break;
			case 1: printft(indent, "==\r\n"); break;
			case 2: printft(indent, "!=\r\n"); break;									
			case 3: printft(indent, "<=\r\n"); break;
			case 4: printft(indent, ">=\r\n"); break;
			case 5: printft(indent, "<\r\n"); break;
			case 6: printft(indent, ">\r\n"); break;
		}
				
		a->eval(indent + 1);
		b->eval(indent + 1);			
	}

	virtual Exp* optimize() 
	{	
		Exp* a1 = a->optimize();
		if( a1 ) 
		{
			Exp* old = a;
			a = a1;
			delete old;
		}
		
		Exp* b1 = b->optimize();
		if( b1 ) 
		{
			Exp* old = b;
			b = b1;
			delete old;
		}			
		
		return 0;	
	}
};


struct ArthimeticExp : Exp
{	
	int  op;
	Exp* a;
	Exp* b;
	
	ArthimeticExp() : op(0)
	{
	}

	virtual void eval(int indent) 
	{
		switch( op )
		{
			case 0: printft(indent, "??\r\n"); break;
			case 1: printft(indent, "+\r\n"); break;
			case 2: printft(indent, "-\r\n"); break;
									
			case 3: printft(indent, "*\r\n"); break;
			case 4: printft(indent, "/\r\n"); break;
			case 5: printft(indent, "%%\r\n"); break;
		}
				
		a->eval(indent + 1);
		b->eval(indent + 1);			
	}

	virtual Exp* optimize() 
	{
		Exp* a1 = a->optimize();
		if( a1 ) 
		{
			Exp* old = a;
			a = a1;
			delete old;
		}
		
		Exp* b1 = b->optimize();
		if( b1 ) 
		{
			Exp* old = b;
			b = b1;
			delete old;
		}
		
		if( op == 1 && canOptimize == true )
		{
			LiteralExpr* literal_a = dynamic_cast<LiteralExpr*>(a);
			LiteralExpr* literal_b = dynamic_cast<LiteralExpr*>(b);
			if( literal_a && literal_b ) 
			{
				float result = literal_a->literal + literal_b->literal;																
				LiteralExpr* r = new LiteralExpr();
				r->literal = result;
				r->canOptimize = true;
				return r;
			}								
		}	
		
		else if( op == 2 && canOptimize == true )
		{
			LiteralExpr* literal_a = dynamic_cast<LiteralExpr*>(a);
			LiteralExpr* literal_b = dynamic_cast<LiteralExpr*>(b);
			if( literal_a && literal_b ) 
			{
				float result = literal_a->literal - literal_b->literal;																
				LiteralExpr* r = new LiteralExpr();
				r->literal = result;
				r->canOptimize = true;
				return r;
			}								
		}	
		
		else if( op == 3 && canOptimize == true )
		{
			LiteralExpr* literal_a = dynamic_cast<LiteralExpr*>(a);
			LiteralExpr* literal_b = dynamic_cast<LiteralExpr*>(b);
			if( literal_a && literal_b ) 
			{
				float result = literal_a->literal * literal_b->literal;																
				LiteralExpr* r = new LiteralExpr();
				r->literal = result;
				r->canOptimize = true;
				return r;
			}								
		}				
		
		else if( op == 4 && canOptimize == true )
		{
			LiteralExpr* literal_a = dynamic_cast<LiteralExpr*>(a);
			LiteralExpr* literal_b = dynamic_cast<LiteralExpr*>(b);
			if( literal_a && literal_b ) 
			{
				float result = literal_a->literal / literal_b->literal;																
				LiteralExpr* r = new LiteralExpr();
				r->literal = result;
				r->canOptimize = true;
				return r;
			}								
		}	
		
		else if( op == 5 && canOptimize == true )
		{
			LiteralExpr* literal_a = dynamic_cast<LiteralExpr*>(a);
			LiteralExpr* literal_b = dynamic_cast<LiteralExpr*>(b);
			if( literal_a && literal_b ) 
			{
				float result = fmodf( literal_a->literal, literal_b->literal );
				LiteralExpr* r = new LiteralExpr();
				r->literal = result;
				r->canOptimize = true;
				return r;
			}								
		}				
		
		return 0;	
	}
};


struct AndExpr : Exp
{
	Exp* a;
	Exp* b;

	virtual void eval(int indent) 
	{
		printft(indent, "&&\r\n");		
		a->eval(indent + 1);
		b->eval(indent + 1);
	}
	
	virtual Exp* optimize() 
	{
		Exp* a1 = a->optimize();
		if( a1 ) 
		{
			Exp* old = a;
			a = a1;
			delete old;
		}
		
		Exp* b1 = b->optimize();
		if( b1 ) 
		{
			Exp* old = b;
			b = b1;
			delete old;
		}
		return 0;
	}
};

struct OrExpr : Exp
{
	Exp* a;
	Exp* b;

	virtual void eval(int indent) 
	{
		printft(indent, "||\r\n");		
		a->eval(indent + 1);
		b->eval(indent + 1);
	}
	
	virtual Exp* optimize() 
	{
		Exp* a1 = a->optimize();
		if( a1 ) 
		{
			Exp* old = a;
			a = a1;
			delete old;
		}
		
		Exp* b1 = b->optimize();
		if( b1 ) 
		{
			Exp* old = b;
			b = b1;
			delete old;
		}
		return false;
	}
};

struct AssignExpr : Exp
{
	std::wstring value;
	Exp*		 exp;

	virtual void eval(int indent) 
	{
		printft(indent, "assign to %ls\r\n", value.c_str(), exp );
		exp->eval(indent + 1);
	}
	
	virtual Exp* optimize() 
	{
		Exp* p = exp->optimize();
		if( p ) 
		{
			Exp* old = exp;
			exp = p;
			delete old;
		}
		
		return 0;
	}
};

struct NullExpr : Exp
{
	virtual void eval(int indent) 
	{
		printft(indent, "null\r\n");
	}
	
	virtual Exp* optimize() 
	{
		return 0;
	}
};


#include "Scanner.h"

namespace Taste {


class Errors {
public:
	int count;			// number of errors detected

	Errors();
	void SynErr(int line, int col, int n);
	void Error(int line, int col, const wchar_t *s);
	void Warning(int line, int col, const wchar_t *s);
	void Warning(const wchar_t *s);
	void Exception(const wchar_t *s);

}; // Errors

class Parser {
private:
	enum {
		_EOF=0,
		_ident=1,
		_number=2,
		_realCon=3,
		_LeftParenthesis=4,
		_RightParenthesis=5,
		_assignment=6,
		_dot=7,
		_ppOptimize=28
	};
	int maxT;

	Token *dummyToken;
	int errDist;
	int minErrDist;

	void SynErr(int n);
	void Get();
	void Expect(int n);
	bool StartOf(int s);
	void ExpectWeak(int n, int follow);
	bool WeakSeparator(int n, int syFol, int repFol);

public:
	Scanner *scanner;
	Errors  *errors;

	Token *t;			// last recognized token
	Token *la;			// lookahead token

Exp*	results; 
 
bool IsMethodCall()
{
	Token* pt = la;	
	if( pt->kind == _ident )
	{			
		while( pt->kind == _ident || pt->kind == _dot ) {
			pt = scanner->Peek();
		}
		
		if( pt->kind == _LeftParenthesis )
		{
			scanner->ResetPeek();
			return true;
		}
		else
		{	
			scanner->ResetPeek();
			return false;
		}
	}
	else
	{
		scanner->ResetPeek();	
		return false;
	}
}

bool IsAssignment()
{	
	Token* pt = la;	
	if( pt->kind == _ident )
	{			
		while( pt->kind == _ident || pt->kind == _dot ) {
			pt = scanner->Peek();
		}
		
		if( pt->kind == _assignment )
		{
			scanner->ResetPeek();
			return true;
		}
		else
		{	
			scanner->ResetPeek();
			return false;
		}
	}
	else
	{
		scanner->ResetPeek();	
		return false;
	}
}
 
 


	Parser(Scanner *scanner);
	~Parser();
	void SemErr(const wchar_t* msg);

	void C();
	void Block(Exp*& expression);
	void Primary(Exp*& expression);
	void Expr(Exp*& expression);
	void LogOrExpr(Exp*& expression);
	void LogAndExpr(Exp*& expression);
	void CompExpr(Exp*& expression);
	void MultExpr(Exp*& expression);
	void AddExpr(Exp*& expression);
	void UnaryExpr(Exp*& expression);
	void Call(Exp*& expression);
	void Statement(BlockExpr* expression);
	void Arglist(CallExpr* expression);
	void Assignment(Exp*& expression);
	void EmbeddedStatement(Exp*& expression);

	void Parse();

}; // end Parser

} // namespace


#endif

